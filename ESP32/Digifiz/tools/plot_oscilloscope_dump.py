#!/usr/bin/env python3
"""Plot Digifiz oscilloscope dump generated by /oscilloscope_dump endpoint.

Adds FFT-based dominant frequency extraction for both channels.
- Compute base frequency (Hz) for RPM + Speed from FFT peak (non-DC)
- Calibrate: RPM = Hz * 30, Speed = Hz * 0.97
- Print RPM preview to console
- Draw values as text on the matplotlib plot
"""

import argparse
import struct
from pathlib import Path

import matplotlib.pyplot as plt
import numpy as np

HEADER_FMT = "<7I"
HEADER_SIZE = struct.calcsize(HEADER_FMT)
MAGIC = 0x43534F44


def unpack_bits(words: np.ndarray, sample_count: int) -> np.ndarray:
    bits = np.zeros(sample_count, dtype=np.uint8)
    for idx in range(sample_count):
        word = words[idx // 32]
        bits[idx] = (word >> (idx % 32)) & 1
    return bits


def dominant_freq_hz(x_bits: np.ndarray, fs_hz: float) -> float:
    """
    Estimate dominant (baseline) frequency in Hz using FFT peak (excluding DC).
    Uses Hann window + optional parabolic peak interpolation.
    """
    x = x_bits.astype(np.float64)

    # Remove DC offset (important for 0/1 digital signal)
    x = x - np.mean(x)

    n = x.size
    if n < 8:
        return 0.0

    # Window to reduce leakage
    w = np.hanning(n)
    xw = x * w

    # FFT
    spec = np.fft.rfft(xw)
    mag = np.abs(spec)

    # Ignore DC bin
    if mag.size <= 2:
        return 0.0
    mag[0] = 0.0

    k = int(np.argmax(mag))
    if k <= 0 or k >= mag.size - 1:
        # Edge bin, can't interpolate
        return k * fs_hz / n

    # Parabolic interpolation around peak for sub-bin estimate
    a, b, c = mag[k - 1], mag[k], mag[k + 1]
    denom = (a - 2.0 * b + c)
    if denom == 0:
        delta = 0.0
    else:
        delta = 0.5 * (a - c) / denom  # in bins

    k_interp = k + delta
    return float(k_interp * fs_hz / n)


def main() -> None:
    parser = argparse.ArgumentParser(description="Visualize Digifiz oscilloscope dump")
    parser.add_argument("dump", type=Path, help="Path to oscilloscope_dump.bin")
    parser.add_argument("--output", type=Path, help="Save plot to file instead of showing")
    args = parser.parse_args()

    payload = args.dump.read_bytes()
    if len(payload) < HEADER_SIZE:
        raise ValueError("File too small to contain a valid header")

    magic, version, sample_rate_hz, sample_count, packed_words, write_index, wrapped = struct.unpack_from(
        HEADER_FMT, payload, 0
    )
    if magic != MAGIC:
        raise ValueError(f"Unexpected magic: 0x{magic:08X}")
    if version != 1:
        raise ValueError(f"Unsupported version: {version}")

    expected_size = HEADER_SIZE + packed_words * 4 * 2
    if len(payload) != expected_size:
        raise ValueError(f"Unexpected payload size: got {len(payload)}, expected {expected_size}")

    offset = HEADER_SIZE
    rpm_words = np.frombuffer(payload, dtype=np.uint32, count=packed_words, offset=offset)
    speed_words = np.frombuffer(payload, dtype=np.uint32, count=packed_words, offset=offset + packed_words * 4)

    rpm = unpack_bits(rpm_words, sample_count)
    speed = unpack_bits(speed_words, sample_count)

    if wrapped:
        rpm = np.concatenate((rpm[write_index:], rpm[:write_index]))
        speed = np.concatenate((speed[write_index:], speed[:write_index]))

    # --- FFT frequency extraction (Hz) ---
    rpm_hz = dominant_freq_hz(rpm, float(sample_rate_hz))
    speed_hz = dominant_freq_hz(speed, float(sample_rate_hz))

    # --- Calibration ---
    rpm_value = rpm_hz * 30.0
    speed_value = speed_hz * 0.97

    # Preview RPM in console (and include Hz + speed too)
    print(f"RPM base freq: {rpm_hz:.3f} Hz -> RPM: {rpm_value:.1f}")
    print(f"Speed base freq: {speed_hz:.3f} Hz -> Speed: {speed_value:.2f}")

    time_axis = np.arange(sample_count) / sample_rate_hz

    fig, ax = plt.subplots(figsize=(12, 4))
    ax.step(time_axis, rpm + 1.2, where="post", label="RPM input (GPIO35)")
    ax.step(time_axis, speed, where="post", label="Speed input (GPIO39)")

    ax.set_yticks([0, 1.2], ["Speed", "RPM"])
    ax.set_xlabel("Time, s")
    ax.set_ylabel("Digital level")
    ax.set_title("Digifiz oscilloscope capture")
    ax.grid(True, alpha=0.3)
    ax.legend(loc="upper right")

    # Draw text on plot
    info = (
        f"RPM: {rpm_value:.1f}  ({rpm_hz:.3f} Hz)\n"
        f"Speed: {speed_value:.2f}  ({speed_hz:.3f} Hz)"
    )
    ax.text(
        0.01,
        0.98,
        info,
        transform=ax.transAxes,
        va="top",
        ha="left",
        bbox=dict(boxstyle="round,pad=0.3", facecolor="white", alpha=0.8),
    )

    fig.tight_layout()

    if args.output:
        fig.savefig(args.output, dpi=150)
    else:
        plt.show()


if __name__ == "__main__":
    main()
